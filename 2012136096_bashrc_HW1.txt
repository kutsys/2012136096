/.bashrc file Interpretion

line 6,

case $- in
	*i*) ;;
	  *) return;;
esac

# "-" 라는 변수의 중간에 i라는 문자가 포함되어 있을 경우 아무것도 수행하지 않고
# 다른 모든 문자일 경우 리턴해준다.



line 13

HISTCONTROL=ignoreboth

#ignoreboth 의 값을 HISTCONTROL에 넣는다.

line 16,

shopt -s histappend

# 쉘 환경에 대한 세부적인 사항을 설정하는 함수 shopt를 이용하고, -s 옵션 즉 현재 옵션을 사용하게 만든다.
# 쉘이 종료할 때 히스토리 목록을 파일에 덮어쓰지 않고 HISTFILE 변수이 값으로 이름 지어진 파일에 추가한다.

line 19-20

HISTSIZE=1000
HISTFILESIZE=2000

# 일정 갯수(1000개) 이상 사용했던 명령어를 저장하도록 한다.
# HISTFILESIZE는 HISTFILE에 지정한 파일에 기록되는 명령의 수가 가지는 최대값을 정의한다.
# HISTSIZE와 HISTFILESIZE의 값을 지정하는 대입 구문이다.


line 24,

shopt -s checkwinsize

# bash가 명령이 내려진 다음에 윈도우의 사이즈를 체크하도록 설정한다.
# (부가적으로) 필요시 이들의 LINES와 COLUMNS 변수의 값을 변경할 수 있다.

line 31,

[ -x  /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# &&앞의 [ -x file] 명령어는 file이 실행 가능하면 참을 반환한다.
# 즉/usr/bin/lesspipe 파일이 실행 가능한 파일이면 참이다. 실제로 /usr/bin 안에 lesspipe 파일은 실행가능 한 것을 확인하였다.
# &&명령어는 앞의 문장이 참이면 뒤에 문장을 실행한다는 뜻이다. 즉 앞의 파일이 실행가능하면, 뒤에 SHELL 변수가 지정되는 것이다.
# &&뒤의 eval 명령어는 스크립트파일안에서 문자열로 표기된 쉘명령을 실행할 때 사용한다.
# 즉 lesspipe를 쉘로 실행하라는 뜻이다.

line 34,
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
	debian_chroot=$(cat /etc/debian_chroot)
fi

#if문을 사용해서 조건이 참이되면 뒤의 문장을 수행하게끔 한다.
#if의 &&앞의 조건에서 [-z + string]이 사용되었는데 이는 string이 NULL이면 참을 반환하게 된다.
#if의 && 뒤의 조건에서 [-r + file]는, file이 정규적인 파일일 때 참을 반환하게 된다.
#정규적인 파일이란 일반적인 파일에 Standard File I/O 시스템 호출에 의해 참조되는 파일의 일종이다.
#debian_chroot는 bash에서 프롬프트의 세팅에 있어서 필요한 변수이다.
#여기서 if문은 debian_chroot가 비어있지 않고, 그리고 /etc 디렉토리 안에 debian_chroot가 정규 파일일 경우
#debian_chroot에 debian_chroot라는 이름을 덮어 사용하게끔 한다.

line 39
case "$TERM" in
	xterm-color|*-256color) color_prompt=yes;;
esac

#case문을 사용하여 색깔정보가 들어있다고 판단되는 TERM변수를 xterm-color|*-256color를 포함하는 문장으로 제어합니다.
#prompt의 색깔을 설정하는 구문입니다.

line 48,
if [ -n "$force_color_prompt" ]; then
	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	color_prompt=yes
	else
	color_prompt=
	fi
fi

# 첫문장에 if문이 나왔는데, 리눅스의 if문에 [-n string] 타입이 나오면 문자열의 사이즈가 0 이상인지 체크하여 참을 반환하게 해준다.
# force_color_prompt변수 - 아마 색상 지원을 하는데 기여하는 것 같은 - 문자열의 크기가 있다면 다음 if문을 수행하게끔 한다.
# 다음 if문에서 [ -x file ]속성은 file 이 실행 가능한지 체크를 해 주는데, 여기서 /usr/bin 디렉토리 안의 tput 파일의 실행 여부를 검사한다.
# tput의 sataf세팅은 색상을 지정하는데 영향을 주는 요인이다. 여기서 tput setaf 1은 빨간색을 말한다.
# tput setaf를 출력 재지정(> Redirection) 명령에 의해 정상 출력을 /dev/null로 지정한다.
# /dev/null은 어떠한 작업의 출력되는 내용을 보고 싶지 않을때 출력을 이곳으로 보내서 아무것도 안보게 하는 곳이다.
# & 명령어는 명령어는 프로세스를 백그라운드로 실행하는 명령어로써, tput setaf 1 상태를 백그라운드로 실행하는 것으로 보인다.
# 위의 작업이 수행한다면, if-else 조건문에 따라 프롬프트의 색깔에 대한, 즉 color_prompt 설정을 yes로, 그렇지 않다면 별다른 지정을 하지 않는다.

line 59, 
if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi

unset color_prompt force_color_prompt


# PS1 변수에 값을 할당하는 문장이 나온다.
# PS1 환경변수는 bash 쉘에서는 프롬프트의 모양을 바꿀 때 변경한다.
# if문에 의해 조건인 color_prompt 설정이 yes가 되어있을 경우에
# PS1을 ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ 로 지정한다.
# debian_chroot의 \h 속성은 첫 번째 '.' 문자까지의 호스트 이름이며, \u는 현재 유저의 이름이다. (man bash 참고)
# 여기서 01;32m는 Light Green 색상이고, 01;34는 Light Blue 색상이며 이 색상이 프롬프트의 색을 결정한다.
# 그렇지 않다면 PS1을 debian_chroot를 기본세팅으로 둔다. 뒤에나온 \w 속성은 tilde와 함꼐 생략된 $HOME이 있는 현재 워킹 디렉토리라고 한다.

line 64,
unset color_prompt force_color_prompt

# unset 명령어는 선언된 변수를 제거하는 데 사용한다.
# color_prompt와 force_color_prompt 변수를 제거한다.

line 67,
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# TERM 변수에 대한 제어문이다. TERM변수는 /etc/termcap 또는 /usr/lib/terminfo/* 데이타베이스를 사용하여 문자열을 어디로 보낼 지, 커서를 어디로 움직일 지 등등을 결정한다.
# 또한 사용자 백스페이스 키, 기능키 등등이 보낸 문자열을 결정하는데 사용하기도 한다
# case-in 문을 사용해서 TERM 변수에 xterm*|rxvt* 포함된 문자가 있을 시에 PS1 환경변수의 세팅을 해준다.
# 이외에 다른 모든 문자에 대해서는 아무 문장도 수행하지 않는다.

line 76,
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"

# dircolors는 ls의 색상 설정을 하며 환경변수 $LS_COLORS를 설정하는 명령어들로 구성되어 있다.
# /usr/bin 디렉토리에 dircolors 파일을 열 수 있다면 아래의 문장들을 수행한다.
# test문 역시 [ ~ ]문과 같은 역할로서, /.dircolors가 읽을 수 있음을 체크한다.
# &&로 묶인 구문 역시 &&의 앞의 문장이 참이면 그 뒤에 문장을 수행할 수 있게끔 하는 것이며, 뒤에있는 ||는 앞 뒤 둘 중 하나만 참이라도 거기서 수행을 멈추도록 한다.
# 쉘에서 변수가 문자열로 포함된 경우에 이 변수의 본래 값을 보여주는데 많이 쓰는 eval문을 통해 $(dircolors -b ~/.dircolors) , $(dircolors -b) 값으로 참 거짓을 구해낸다.

line 78,
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# alias 변수란 명령들을 사용자 본인이 사용하기 편한 형태로 바꾸어서 사용 하는 것이다.
# 사용자가 ls라는 명령을 입력하면 'ls -- color=auto' 를 입력한 것과 동일하게 된다.
# 아래에 있는 grep, fgrep, egrep입력도 오른쪽에 있는 문장과 같은 기능을 수행한다.
# 여기서 [명령어]--color=auto는 이들 명령어에 대한 색깔을 지정하는 것과 관련이 있다.

line 91,
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# 명령어로 ll, la, l를 입력하면 각각 ls -alF, ls -A, ls -CF로 변환하여 처리한다.

line 97,
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# 오랫동안 실행되는 명령어들을 위해 "alter"를 추가한다고 한다.(주석 설명에 따르면) 역시 alert 명령어를 입력하면 = 뒤의 문장을 입력한 것과 같게 된다.
# notify-send는 데스크탑에 알림을 보낼 프로그램에 대한 명령어로, --urgency=low라고 하면 긴급한 LEVEL을 low(가장낮은 등급)로 설정한다.
# -i 는 icon filename 이나 화면에 보여줄 stock icon을 명시하는 옵션이다. 

line 104,
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# if 문장의 [-f file] 은 해당 file이 directory가 아닌 file인 경우에 참을 돌려준다. 여기서는 /.bash_aliases 파일을 검사하여 이를 정의한다.

line 111,
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# 쉘 환경에 대한 세부적인 사항을 설정하는 shopt가 또 나왔다. 여기서 if문이 나오는데, shopt의 -o 속성에 의해 posix 필드가 on 되어있다는 것을 가정하고 다음 문장을 진행한다.
# posix는 유닉스 운영체계에 기반을 두고 있는 일련의 표준 운영체계 인터페이스라고 할 수 있다.
# /usr/share/bash-completion/bash_completion가 파일일 경우, 그렇지 않고 /etc/bash_completion가 파일일 경우에 각각에 대해 이들을 정의하게 한다.



